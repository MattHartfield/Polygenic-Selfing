// 22nd October 2019
// Modification of recipes 13.2, 13.5
// Polygenic selection under selfâ€“fertilisation, with m traits under selection
// Is there a transition from gene-level to genome-level selection?
// How do the sweep dynamics differ?

// Function for calculating gaussian fitness function for multiple traits
function (f)gaussfit(float z, float z0, float vs){
	fitout = exp(-(0.5)*sum(((z-z0)^2/(vs))));
	return fitout;
}

initialize() {
	
	defineConstant("N",5000);			// Population size
	defineConstant("QTLf",0.05);		// Fraction of mutations that code for QTLs
	defineConstant("mutvar",0.005);	// Mutational variance
	
//	defineConstant("s",0.0);			// Background mutation selection coefficient
//	defineConstant("h",0.2);			// Background mutation dominance coefficient
//	defineConstant("sfrate",0.0);		// Self-fertilisation rate
//	defineConstant("nt",1); 			// Number of traits to optimise
//	defineConstant("newo",0.1);		// New optimum after trait shift

	defineConstant("ShiftTime",5*N);
	defineConstant("MaxTime",3*ShiftTime);
	defineConstant("ExtraTime",4);	// 'ExtraTime'*N reps to be run after optimum reached
	
	defineConstant("fname",paste0(c("/scratch/mhartfield/polyself_out/data/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,".dat")));
//	defineConstant("fname",paste0(c("/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM Scripts/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,".dat")));
	
	initializeMutationType("m1", h, "f", s); 	 			// Fitness of background mutations (set to zero for neutral)
	initializeMutationType("m2", 0.5, "f", 0.0);  	 	// QTLs		
	m2.convertToSubstitution = F;
	m2.color="green";
	
	initializeGenomicElementType("g1", c(m1,m2), c(1.0-QTLf,QTLf));
//	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, 99999);
	
	mu = 0.028/(100000*(1.0-QTLf));
//	mu = 1e-7;
	rec = (2.5*0.01)/(1000000);
	initializeMutationRate(mu);
	initializeRecombinationRate(rec);
	
	// Setting up multivariate trait matrix
	defineConstant("QTL_mean",rep(0.0,nt));
	defineConstant("QTL_io",rep(0.0,nt));			// Initial optimum = 0
	defineConstant("QTL_so",rep(newo,nt));			// Shifted optimum	
	defineConstant("QTL_V",mutvar);					// Variance in mutational effects
	defineConstant("QTL_CV",0.0);						// Co-variance in mutational effects
	
	// Setting up array to be used to define QTL covariance matrix
	mat_ent = rep(QTL_CV,nt*nt);
	for (i in 1:nt)
	{
		ent = 0.0 + (i-1)*(nt+1);
		mat_ent[ent] = QTL_V;
	}
	defineConstant("QTL_matrix",matrix(mat_ent,nrow=nt));
	print(QTL_matrix);
}

// Defining fitness of QTL mutations using MVN setup
mutation(m2)
{
	if(nt > 1)
	{
		effects = rmvnorm(1,QTL_mean,QTL_matrix);
		for(i in 1:nt)
		{
			mut.setValue( paste0(c("e",(i-1))) , effects[i-1]);
		}
	}
	else if (nt == 1)
	{
		effects = rnorm(1,QTL_mean,QTL_V);
		mut.setValue( "e0" , effects);
	}
	return T;
}

// Code to define fitness changes due to effects of QTLs
// Then output key statistics
late () {

	if (sim.generation % 500 == 0){
		catn("Generation number " + sim.generation);
	}
	
	if (sim.generation == ShiftTime){
		catn("Optimum shift at generation " + sim.generation);
	}
	
	if (sim.generation % 100 == 0){
		cumphen = rep(0.0,nt);			// Cumulative phenotype (for mean)
		cumphensq = rep(0.0,nt);		// Cumulative square of phenotype (for variance)
		cumfit = 0.0;						// Cumulative fitness (for mean)
		cumfitsq = 0.0;					// Cumulative square of fitness (for variance)
	}
	
	for (ind in sim.subpopulations.individuals)
	{
			
		// QTL loci
		phens = rep(0.0,nt);
		mQTL = ind.genomes.mutationsOfType(m2);
		if(size(mQTL) != 0){
			for(i in 1:nt)
			{
				phens[(i-1)] = sum(mQTL.getValue(paste0(c("e",(i-1)))));
				if (sim.generation % 100 == 0){
					cumphen[(i-1)] = cumphen[(i-1)] + phens[(i-1)];
					cumphensq[(i-1)] = cumphensq[(i-1)] + (phens[(i-1)])^2;				
				}
			}
		}
		
		// Fitness scaling of QTLs based on Gaussian function with selection variance = 1
		if(sim.generation < ShiftTime)
		{
			ind.fitnessScaling = gaussfit(phens,QTL_io,rep(1.0,nt));
		}
		else if(sim.generation >= ShiftTime)
		{
			ind.fitnessScaling = gaussfit(phens,QTL_so,rep(1.0,nt));
		}
		
		if (sim.generation % 100 == 0){
			cumfit = cumfit + ind.fitnessScaling;
			cumfitsq = cumfitsq + (ind.fitnessScaling)^2;
		}
		
	}
	
	// Outputting key statistics
	if (sim.generation % 100 == 0){
		qtls = sim.mutationsOfType(m2);
		fmuts = sum(sim.mutationFrequencies(NULL, qtls) == 1.0);
		line = paste(c(sim.generation, cumfit/N, (cumfitsq/N) - (cumfit/N)^2, fmuts));
		if(sim.generation == ShiftTime)
		{
			// Fitness before optimum shift
			defineConstant("mpfit",cumfit/N);
//			print(mpfit);
		}
		for(i in 1:nt)
		{
			line = c(line,cumphen[(i-1)]/N);
			line = c(line,(cumphensq[(i-1)]/N) - (cumphen[(i-1)]/N)^2);
		}

//		if(sim.generation > ShiftTime)
//		{
//			print(cumfit/N);
//			print(abs(((cumfit/N) - mpfit)/mpfit));
//			print((cumphen/N));
//			print((abs((cumphen/N) - QTL_so)/QTL_so));
//			catn();
//		}	
		writeFile(fname, paste(line), append=T);
		
		// If fitness following optimum shift gets to within 1% of pre-shift fitness, end simulation
		if(sim.generation > ShiftTime) 
		{
		
			if( sim.getValue('hasfixed') == 0 ){
			
				// Conditions for fixation:
				// If fitness is within 95% of that before optimum shift
				// And at least 50% of traits have reached optimum value (within 95% of new value)
				
				isfit=0;
				isopt=0;
				if((abs(((cumfit/N) - mpfit)/mpfit) < 0.05))
				{
					isfit = 1;
				}
				
				noph = 0;
				for(i in 1:nt)
				{
					if((abs(((cumphen[(i-1)]/N) - newo)/newo) < 0.05))
					{
						noph = noph + 1;
					}
				}
				if(noph >= (nt/2))
				{
					isopt = 1;
				}
				
				if( (isfit+isopt)==2 )
				{
					catn("Population reached new optimum at generation " + sim.generation + ".");
					catn("Running for " + ExtraTime + "N more generations.");
					sim.setValue('optime',sim.generation);
					sim.setValue('hasfixed',1);
					// Reschedule end block so extra time is sure to run
					sim.rescheduleScriptBlock(s1,(sim.getValue('optime') + 2*ExtraTime*N),(sim.getValue('optime') + 2*ExtraTime*N));
				}
			}
			
			if( sim.getValue('hasfixed') == 1 ){
				if(sim.generation > (sim.getValue('optime') + ExtraTime*N)) 
				{
					catn("End of simulation after optimum reached.");
					sim.simulationFinished();
				}
			}

			
		}
		
	}	
}

1 {
	// Set up subpop size and printouts
	sim.addSubpop("p1", N);
	p1.setSelfingRate(sfrate);
	line = c("Generation", "MeanFitness", "VarFitness", "FixedMuts");
	for(i in 1:nt)
	{
		line = c(line,paste0(c("MeanTrait",i)));
		line = c(line,paste0(c("VarTrait",i)));
	}
	writeFile(fname, paste(line), append=F);
	sim.rescheduleScriptBlock(s1,MaxTime,MaxTime);
	sim.setValue('hasfixed',0);
}

// To be run after 'MaxTime' generations: terminate simulation if new optimum not reached
s1 10 {
	catn("Population failed to reach new optimum.");
	sim.simulationFinished();
}

// EOF