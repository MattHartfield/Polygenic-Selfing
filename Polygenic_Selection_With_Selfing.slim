// 22nd October 2019
// Modification of recipes 13.2, 13.5
// Polygenic selection under selfâ€“fertilisation, with m traits under selection
// Is there a transition from gene-level to genome-level selection?
// How do the sweep dynamics differ?

// Function for calculating gaussian fitness function for multiple traits
function (f)gaussfit(float z, float z0, float vs){
	fitout = exp(-(0.5)*sum(((z-z0)^2/(vs))));
	return fitout;
}

initialize() {
	
	defineConstant("N",5000);				// Population size
	defineConstant("QTLf",0.1);			// Fraction of mutations that code for QTLs
	defineConstant("genl",30000000);		// Length of simulated genome
	
	// Uncomment if running on home machine; comment out otherwise
//	defineConstant("s",0.0);				// Background mutation selection coefficient
//	defineConstant("h",0.02);				// Background mutation dominance coefficient
//	defineConstant("sfrate",0.0);			// Self-fertilisation rate
//	defineConstant("nt",1); 				// Number of traits to optimise
//	defineConstant("newo",1.0);			// New optimum after trait shift
//	defineConstant("mvar",0.25);			// New optimum after trait shift
//	defineConstant("fname",paste0(c("/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM Scripts/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_mvar",mvar,".dat")));
	
	// Uncomment if running on remote machine; comment out otherwise
	defineConstant("fname",paste0(c("/scratch/mhartfield/polyself_out/data/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_mvar",mvar,".dat")));
	
	defineConstant("ShiftTime",5*N);
	defineConstant("MaxTime",3*ShiftTime);
	defineConstant("ExtraTime",4);		// 'ExtraTime'*N reps to be run after optimum reached
	defineConstant("mutvar",mvar);		// Mutational variance
	
	initializeMutationType("m1", h, "f", s); 	 			// Fitness of background mutations (set to zero for neutral)
	initializeMutationType("m2", 0.5, "f", 0.0);  	 	// QTLs		
	m1.mutationStackPolicy = "f";
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "f";
	m2.color="green";
	
	initializeGenomicElementType("g1", c(m1,m2), c(1.0-QTLf,QTLf));
	//	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, genl-1);
	
	// Uncomment if using Arabidopsis-type parameters
	mu = 1e-9;
	rec = ((3.6*0.01)/(1000000-1));
	
	// Uncomment if using testing values
//	mu = 1e-6;
//	rec = 0.0005;
	
	initializeMutationRate(mu);
	initializeRecombinationRate(rec);
	
	// Setting up multivariate trait matrix
	defineConstant("QTL_mean",rep(0.0,nt));
	defineConstant("QTL_io",rep(0.0,nt));			// Initial optimum = 0
	defineConstant("QTL_so",rep(newo,nt));			// Shifted optimum	
	defineConstant("QTL_V",mutvar);					// Variance in mutational effects
	defineConstant("QTL_CV",0.0);						// Co-variance in mutational effects
	
	// Setting up array to be used to define QTL covariance matrix
	mat_ent = rep(QTL_CV,nt*nt);
	for (i in 1:nt)
	{
		ent = 0.0 + (i-1)*(nt+1);
		mat_ent[ent] = QTL_V;
	}
	defineConstant("QTL_matrix",matrix(mat_ent,nrow=nt));
	print(QTL_matrix);
}

// Calculating fitness contributed by QTLs
fitness(NULL)
{
	phens = rep(0.0,nt);
	mQTL = individual.genomes.mutationsOfType(m2);
	if(size(mQTL) != 0){
		for(i in 1:nt)
		{
			phens[(i-1)] = sum(mQTL.getValue(paste0(c("e",(i-1)))));
		}
	}
		
	// Fitness scaling of QTLs based on Gaussian function with selection variance = 1
	if(sim.generation < ShiftTime)
	{
		return gaussfit(phens,QTL_io,rep(1.0,nt));
	}
	else if(sim.generation >= ShiftTime)
	{
		return gaussfit(phens,QTL_so,rep(1.0,nt));
	}
}

// Defining selection coefficient of QTL mutations using MVN setup (in base population)
mutation(m2,p1)
{
	if(nt > 1)
	{
		effects = rmvnorm(1,QTL_mean,QTL_matrix);
		for(i in 1:nt)
		{
			mut.setValue( paste0(c("e",(i-1))) , effects[i-1]);
		}
	}
	else if (nt == 1)
	{
		effects = rnorm(1,QTL_mean,QTL_V);
		mut.setValue( "e0" , effects);
	}
	return T;
}

// Supressing ALL mutation in p2, p3 (subpops in which inbreeding depression is measured)
mutation(m1,p2)
{
	return F;
}
mutation(m2,p2)
{
	return F;
}
mutation(m1,p3)
{
	return F;
}
mutation(m2,p3)
{
	return F;
}

// Code to define fitness changes due to QTLs
late () {
	
	if (sim.generation % 500 == 0){
		catn("Generation number " + sim.generation);
	}
	
	if (sim.generation == ShiftTime){
		catn("Optimum shift at generation " + sim.generation);
	}
	
	// Printing out ms stats of 100 haplotypes, for subsequent calculation of haplotype statistics
	if (sim.generation == (ShiftTime-1)){
	
		// Obtaining distribution of trait values from all indvs, see if normally distributed
		m2mut = sim.mutationsOfType(m2);
		m2f = sim.mutationFrequencies(p1,m2mut);
		m2mut = m2mut[which(m2f >= 0.05)];
		m2f = sim.mutationFrequencies(p1,m2mut);
		m2mut = m2mut[which(m2f <= 0.95)];
		slimgui.pauseExecution();
		
//		phens = rep(0.0,N);
//		ct = 0;

//		for(ind in p1.individuals)
//		{
//			mQTL = ind.genomes.mutationsOfType(m2);
//			if(size(mQTL) != 0){
//				phens[ct] = sum(mQTL.getValue("e0"));
//			}
//			ct = ct + 1;
//		}
//		writeFile("/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM scripts/PhenOut.dat",paste(m2mut.getValue("e0")));
		writeFile(paste0(c("/scratch/mhartfield/polyself_out/phendat/phendat_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_mvar",mvar,"_beforeshift.dat")),paste(m2mut.getValue("e0")));
	
//		p1.outputMSSample(100,replace=F,filePath="/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM scripts/MSout/MSout_test_BeforeShift.ms");
		p1.outputMSSample(100,replace=F,filePath=paste0(c("/scratch/mhartfield/polyself_out/ms/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_mvar",mvar,"_beforeshift.ms")));
	}
	
	if (sim.generation == (ShiftTime + N)){
//		p1.outputMSSample(100,replace=F,filePath="/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM scripts/MSout/VCFout_test_AfterShift.ms");
		p1.outputMSSample(100,replace=F,filePath=paste0(c("/scratch/mhartfield/polyself_out/ms/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_mvar",mvar,"_aftershift.ms")));
	}
	
	if (sim.generation == (sim.getValue('optime') + ExtraTime*N + 99)){
//		p1.outputMSSample(100,replace=F,filePath="/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM scripts/MSout/MSout_test_SimEnd.ms");
		p1.outputMSSample(100,replace=F,filePath=paste0(c("/scratch/mhartfield/polyself_out/ms/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_mvar",mvar,"_simend.ms")));
	}

}

// Outputting key statistics every 100 generations
early () {

	if (sim.generation % 100 == 0){
		// Splitting off subpopulations, for measuring inbreeding depression
		sim.addSubpopSplit("p2",500,p1);
		sim.addSubpopSplit("p3",500,p1);
		p2.setSelfingRate(0.0);
		p3.setSelfingRate(1.0);
	}

	if (sim.generation % 100 == 1 & sim.generation != 1){
		cumphen = rep(0.0,nt);			// Cumulative phenotype (for mean)
		cumphensq = rep(0.0,nt);		// Cumulative square of phenotype (for variance)
		cumfit = 0.0;						// Cumulative fitness (for mean)
		cumfitsq = 0.0;					// Cumulative square of fitness (for variance)
		genvar = rep(0.0,nt);			// Genetic variance
		fixeff = rep(0.0,nt);			// Mean QTL effects of mutants that fix
		proppos = rep(0.0,nt);			// Proportion of QTLs with +ve effects
		fepos = rep(0.0,nt);				// Mean QTL effects of fixed *positive* mutations
		
		// QTL loci
		phens = rep(0.0,nt);
		for (ind in p1.individuals)
		{
			mQTL = ind.genomes.mutationsOfType(m2);
			if(size(mQTL) != 0){
				for(i in 1:nt)
				{
					phens[(i-1)] = sum(mQTL.getValue(paste0(c("e",(i-1)))));
					cumphen[(i-1)] = cumphen[(i-1)] + phens[(i-1)];
					cumphensq[(i-1)] = cumphensq[(i-1)] + (phens[(i-1)])^2;
				}
			}			
		}
		
		qtls = sim.mutationsOfType(m2);
		qtlf = sim.mutationFrequencies(p1,qtls);
		fmuts = sum(qtlf == 1.0);
		line = paste(c(sim.generation, mean(p1.cachedFitness(NULL)), var(p1.cachedFitness(NULL)), fmuts));
		
		// Measuring inbreeding depression, deleting subpopulations
		id = 1.0 - (mean(p3.cachedFitness(NULL))/mean(p2.cachedFitness(NULL)));
		line = c(line,id);
		p2.setSubpopulationSize(0);
		p3.setSubpopulationSize(0);
		
		if (sim.generation == ShiftTime-99){
			// Fitness before optimum shift
			defineConstant("mpfit",mean(p1.cachedFitness(NULL)));
//			catn("mpfit is " + mpfit);
		}
		
		for(i in 1:nt)
		{
			if(size(qtls) != 0)
			{
				// Calculating genetic variance
				qtle = qtls.getValue(paste0(c("e",(i-1))));
				genvar[(i-1)] = sum(2*qtlf*(1.0-qtlf)*qtle*qtle);
				if(size(qtle[which(qtlf==1.0)]) == 0)
				{
					fixeff[(i-1)] = NAN;
					proppos[(i-1)] = NAN;
					fepos[(i-1)] = NAN;
				}
				else
				{
					fixeff[(i-1)] = mean(qtle[which(qtlf==1.0)]);
					proppos[(i-1)] = size(qtle[which(qtlf==1.0 & qtle>0.0)])/size(qtle[which(qtlf==1.0)]);
					if(size(qtle[which(qtlf==1.0 & qtle>0.0)]) > 0)
					{
						fepos[(i-1)] = mean(qtle[which(qtlf==1.0 & qtle>0.0)]);
					}
					else
					{
						fepos[(i-1)] = NAN;
					}
				}
			}
			else
			{
				genvar[(i-1)] = 0.0;
				fixeff[(i-1)] = NAN;
				proppos[(i-1)] = NAN;
				fepos[(i-1)] = NAN;
			}
			
			// Printing out mean individual phenotype; variance in indv phenotype; population genetic variance
			line = c(line,cumphen[(i-1)]/N);
			line = c(line,(cumphensq[(i-1)]/N) - (cumphen[(i-1)]/N)^2);
			line = c(line,genvar[(i-1)]);
			line = c(line,fixeff[(i-1)]);
			line = c(line,proppos[(i-1)]);
			line = c(line,fepos[(i-1)]);
		}
		
		// Outputting statistics
		writeFile(fname, paste(line), append=T);
		
		// If fitness following optimum shift gets to within 1% of pre-shift fitness, end simulation
		if(sim.generation > ShiftTime)
		{
			
			if( sim.getValue('hasfixed') == 0 ){
				
				// Conditions for fixation:
				// If fitness is within 95% of that before optimum shift
				// And at least 50% of traits have reached optimum value (within 95% of new value)
				
				isfit=0;
				isopt=0;
				if((abs((mean(p1.cachedFitness(NULL)) - mpfit)/mpfit) < 0.05))
				{
					isfit = 1;
				}
				
				noph = 0;
				for(i in 1:nt)
				{
					if((abs(((cumphen[(i-1)]/N) - newo)/newo) < 0.05))
					{
						noph = noph + 1;
					}
				}
				if(noph >= (nt/2))
				{
					isopt = 1;
				}
							
				if( (isfit+isopt)==2 )
				{
					catn("Population reached new optimum at generation " + sim.generation + ".");
					catn("Running for " + ExtraTime + "N more generations.");
					sim.setValue('optime',sim.generation);
					sim.setValue('hasfixed',1);
					// Reschedule end block so extra time is sure to run
					sim.rescheduleScriptBlock(s1,(sim.getValue('optime') + 2*ExtraTime*N),(sim.getValue('optime') + 2*ExtraTime*N));
				}
			}
			
			if( sim.getValue('hasfixed') == 1 ){
				if(sim.generation > (sim.getValue('optime') + ExtraTime*N))
				{
					catn("End of simulation after optimum reached.");
					sim.simulationFinished();
				}
			}
		}
	}
		
}

1 {
	// Set up population size and printouts
	sim.addSubpop("p1", N);
	p1.setSelfingRate(sfrate);
	line = c("Generation", "MeanFitness", "VarFitness", "FixedMuts","InbreedingDepression");
	for(i in 1:nt)
	{
		line = c(line,paste0(c("MeanTrait",i)));
		line = c(line,paste0(c("VarTrait",i)));
		line = c(line,paste0(c("GenVar",i)));
		line = c(line,paste0(c("MeanFixedQTL",i)));
		line = c(line,paste0(c("PropPosQTL",i)));
		line = c(line,paste0(c("MeanPosQTL",i)));
	}
	writeFile(fname, paste(line), append=F);
	sim.rescheduleScriptBlock(s1,MaxTime,MaxTime);
	sim.setValue('hasfixed',0);
	sim.setValue('optime',MaxTime);
}

// To be run after 'MaxTime' generations: terminate simulation if new optimum not reached
s1 10 late() {
	catn("Population failed to reach new optimum.");
	// Print off haplotype sample at sim end
//	p1.outputMSSample(100,replace=F,filePath="/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM scripts/MSout/MSout_test_SimEnd.ms");
	p1.outputMSSample(100,replace=F,filePath=paste0(c("/scratch/mhartfield/polyself_out/ms/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_mvar",mvar,"_simend.ms")));
	sim.simulationFinished();
}

// EOF