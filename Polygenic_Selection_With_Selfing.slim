// 22nd October 2019
// Modification of recipes 13.2, 13.5
// Polygenic selection under selfâ€“fertilisation, with m traits under selection
// Is there a transition from gene-level to genome-level selection?
// How do the sweep dynamics differ?

// Function for calculating gaussian fitness function for multiple traits
function (f)gaussfit(float z, float z0, float vs){
	fitout = exp(-(0.5)*sum(((z-z0)^2/(vs))));
	return fitout;
}

initialize() {
	
	defineConstant("N",5000);			// Population size
	defineConstant("QTLf",0.1);		// Fraction of mutations that code for QTLs

	// Uncomment if running on home machine; comment out otherwise
//	defineConstant("s",0.0);			// Background mutation selection coefficient
//	defineConstant("h",0.2);			// Background mutation dominance coefficient
//	defineConstant("sfrate",0.0);		// Self-fertilisation rate
//	defineConstant("nt",1); 			// Number of traits to optimise
//	defineConstant("newo",1.0);		// New optimum after trait shift
//	defineConstant("mvar",0.25);		// New optimum after trait shift
//	defineConstant("fname",paste0(c("/scratch/mhartfield/polyself_out/data/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_mvar",mvar,".dat")));

	// Uncomment if running on remote machine; comment out otherwise
	defineConstant("fname",paste0(c("/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM Scripts/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_mvar",mvar,".dat")));

	defineConstant("ShiftTime",5*N);
	defineConstant("MaxTime",2*ShiftTime);
	defineConstant("ExtraTime",1);	// 'ExtraTime'*N reps to be run after optimum reached
	defineConstant("mutvar",mvar);		// Mutational variance
	
	initializeMutationType("m1", h, "f", s); 	 			// Fitness of background mutations (set to zero for neutral)
	initializeMutationType("m2", 0.5, "f", 0.0);  	 	// QTLs		
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "f";
	m2.color="green";
	
	initializeGenomicElementType("g1", c(m1,m2), c(1.0-QTLf,QTLf));
//	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, 99999);
	
	// Uncomment if running on remote machine; comment out otherwise
	mu = 0.028/(100000);
	rec = (2.5*0.01)/(1000000);
	
	// Uncomment if *testing* on remote machine; comment out otherwise
//	mu = 1e-6;	
//	rec = 0.0005;

	initializeMutationRate(mu);
	initializeRecombinationRate(rec);
	
	// Setting up multivariate trait matrix
	defineConstant("QTL_mean",rep(0.0,nt));
	defineConstant("QTL_io",rep(0.0,nt));			// Initial optimum = 0
	defineConstant("QTL_so",rep(newo,nt));			// Shifted optimum	
	defineConstant("QTL_V",mutvar);					// Variance in mutational effects
	defineConstant("QTL_CV",0.0);						// Co-variance in mutational effects
	
	// Setting up array to be used to define QTL covariance matrix
	mat_ent = rep(QTL_CV,nt*nt);
	for (i in 1:nt)
	{
		ent = 0.0 + (i-1)*(nt+1);
		mat_ent[ent] = QTL_V;
	}
	defineConstant("QTL_matrix",matrix(mat_ent,nrow=nt));
	print(QTL_matrix);
}

// Defining fitness of QTL mutations using MVN setup
mutation(m2)
{
	if(nt > 1)
	{
		effects = rmvnorm(1,QTL_mean,QTL_matrix);
		for(i in 1:nt)
		{
			mut.setValue( paste0(c("e",(i-1))) , effects[i-1]);
		}
	}
	else if (nt == 1)
	{
		effects = rnorm(1,QTL_mean,QTL_V);
		mut.setValue( "e0" , effects);
	}
	return T;
}

// Code to define fitness changes due to effects of QTLs
// Then output key statistics
late () {

	if (sim.generation % 500 == 0){
		catn("Generation number " + sim.generation);
	}
	
	if (sim.generation == ShiftTime){
		catn("Optimum shift at generation " + sim.generation);
	}
	
	if (sim.generation % 100 == 0){
		cumphen = rep(0.0,nt);			// Cumulative phenotype (for mean)
		cumphensq = rep(0.0,nt);		// Cumulative square of phenotype (for variance)
		cumfit = 0.0;						// Cumulative fitness (for mean)
		cumfitsq = 0.0;					// Cumulative square of fitness (for variance)
		genvar = rep(0.0,nt);			// Genetic variance
		fixeff = rep(0.0,nt);			// Mean QTL effects of mutants that fix
		proppos = rep(0.0,nt);			// Proportion of QTLs with +ve effects
		fepos = rep(0.0,nt);				// Mean QTL effects of fixed *positive* mutations
	}
	
	// Calculating genetic variance
	qtls = sim.mutationsOfType(m2);
	
	for (ind in sim.subpopulations.individuals)
	{
		
		// QTL loci
		phens = rep(0.0,nt);
		mQTL = ind.genomes.mutationsOfType(m2);
		if(size(mQTL) != 0){
			for(i in 1:nt)
			{
				phens[(i-1)] = sum(mQTL.getValue(paste0(c("e",(i-1)))));
				if (sim.generation % 100 == 0){
					cumphen[(i-1)] = cumphen[(i-1)] + phens[(i-1)];
					cumphensq[(i-1)] = cumphensq[(i-1)] + (phens[(i-1)])^2;				
				}
			}
		}
		
		// Fitness scaling of QTLs based on Gaussian function with selection variance = 1
		if(sim.generation < ShiftTime)
		{
			ind.fitnessScaling = gaussfit(phens,QTL_io,rep(1.0,nt));
		}
		else if(sim.generation >= ShiftTime)
		{
			ind.fitnessScaling = gaussfit(phens,QTL_so,rep(1.0,nt));
		}
		
		if (sim.generation % 100 == 0){
			cumfit = cumfit + ind.fitnessScaling;
			cumfitsq = cumfitsq + (ind.fitnessScaling)^2;
		}
		
	}
	
	// Outputting key statistics
	if (sim.generation % 100 == 0){
	
		// Histogram of phenotype values (using code from recipe 14.8)
//		rstr = paste(c('{',
//		'quartz(width=4, height=4, type="pdf", file="' + pdfPath + '")',
//		'y <- c(' + paste(allphens, sep=", ") + ')',
//		'hist(y)',
//		'box()',
//		'dev.off()',
//		'}'), sep="\n");
//		
//		scriptPath = writeTempFile("plot_", ".R", rstr);
//		system("/usr/local/bin/Rscript", args=scriptPath);
	
		qtls = sim.mutationsOfType(m2);
		qtlf = sim.mutationFrequencies(NULL,qtls);
		fmuts = sum(qtlf == 1.0);
		line = paste(c(sim.generation, cumfit/N, (cumfitsq/N) - (cumfit/N)^2, fmuts));
		if(sim.generation == ShiftTime)
		{
			// Fitness before optimum shift
			defineConstant("mpfit",cumfit/N);
//			print(mpfit);
		}
		for(i in 1:nt)
		{
			// Calculating genetic variance
			qtle = qtls.getValue(paste0(c("e",(i-1))));
			genvar[(i-1)] = sum(2*qtlf*(1.0-qtlf)*qtle*qtle);
			if(size(qtle[which(qtlf==1.0)]) == 0)
			{
				fixeff[(i-1)] = NAN;
				proppos[(i-1)] = NAN;
				fepos[(i-1)] = NAN;
			}
			else
			{
				fixeff[(i-1)] = mean(qtle[which(qtlf==1.0)]);
				proppos[(i-1)] = size(qtle[which(qtlf==1.0 & qtle>0.0)])/size(qtle[which(qtlf==1.0)]);
				if(size(qtle[which(qtlf==1.0 & qtle>0.0)]) > 0)
				{
					fepos[(i-1)] = mean(qtle[which(qtlf==1.0 & qtle>0.0)]);
				}
				else
				{
					fepos[(i-1)] = NAN;
				}
			}
			
			// Printing out mean individual phenotype; variance in indv phenotype; population genetic variance
			line = c(line,cumphen[(i-1)]/N);
			line = c(line,(cumphensq[(i-1)]/N) - (cumphen[(i-1)]/N)^2);
			line = c(line,genvar[(i-1)]);
			line = c(line,fixeff[(i-1)]);
			line = c(line,proppos[(i-1)]);
			line = c(line,fepos[(i-1)]);			
		}
//		catn(genvar);

//		if(sim.generation > ShiftTime)
//		{
//			print(cumfit/N);
//			print(abs(((cumfit/N) - mpfit)/mpfit));
//			print((cumphen/N));
//			print((abs((cumphen/N) - QTL_so)/QTL_so));
//			catn();
//		}	
		writeFile(fname, paste(line), append=T);
		
		// If fitness following optimum shift gets to within 1% of pre-shift fitness, end simulation
		if(sim.generation > ShiftTime) 
		{
		
			if( sim.getValue('hasfixed') == 0 ){
			
				// Conditions for fixation:
				// If fitness is within 95% of that before optimum shift
				// And at least 50% of traits have reached optimum value (within 95% of new value)
				
				isfit=0;
				isopt=0;
				if((abs(((cumfit/N) - mpfit)/mpfit) < 0.05))
				{
					isfit = 1;
				}
				
				noph = 0;
				for(i in 1:nt)
				{
					if((abs(((cumphen[(i-1)]/N) - newo)/newo) < 0.05))
					{
						noph = noph + 1;
					}
				}
				if(noph >= (nt/2))
				{
					isopt = 1;
				}
				
				if( (isfit+isopt)==2 )
				{
					catn("Population reached new optimum at generation " + sim.generation + ".");
					catn("Running for " + ExtraTime + "N more generations.");
					sim.setValue('optime',sim.generation);
					sim.setValue('hasfixed',1);
					// Reschedule end block so extra time is sure to run
					sim.rescheduleScriptBlock(s1,(sim.getValue('optime') + 2*ExtraTime*N),(sim.getValue('optime') + 2*ExtraTime*N));
				}
			}
			
			if( sim.getValue('hasfixed') == 1 ){
				if(sim.generation > (sim.getValue('optime') + ExtraTime*N)) 
				{
					catn("End of simulation after optimum reached.");
					sim.simulationFinished();
				}
			}
				
		}
	}	
}

1 {
	// Set up subpop size and printouts
	sim.addSubpop("p1", N);
	p1.setSelfingRate(sfrate);
	line = c("Generation", "MeanFitness", "VarFitness", "FixedMuts");
	for(i in 1:nt)
	{
		line = c(line,paste0(c("MeanTrait",i)));
		line = c(line,paste0(c("VarTrait",i)));
		line = c(line,paste0(c("GenVar",i)));
		line = c(line,paste0(c("MeanFixedQTL",i)));	
		line = c(line,paste0(c("PropPosQTL",i)));	
		line = c(line,paste0(c("MeanPosQTL",i)));		
	}
	writeFile(fname, paste(line), append=F);
	sim.rescheduleScriptBlock(s1,MaxTime,MaxTime);
	sim.setValue('hasfixed',0);
	
//	defineConstant("pdfPath", writeTempFile("plot_", ".pdf", ""));
//	
//	// If we're running in SLiMgui, open a plot window
//	if (exists("slimgui"))
//		slimgui.openDocument(pdfPath);
}

// To be run after 'MaxTime' generations: terminate simulation if new optimum not reached
s1 10 {
	catn("Population failed to reach new optimum.");
	sim.simulationFinished();
}

// EOF