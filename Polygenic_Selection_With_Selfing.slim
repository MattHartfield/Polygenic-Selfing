// 22nd October 2019
// Modification of recipes 13.2, 13.5
// Polygenic selection under selfâ€“fertilisation, with m traits under selection
// Is there a transition from gene-level to genome-level selection?
// How do the sweep dynamics differ?

// Function for calculating gaussian fitness function for multiple traits
function (f)gaussfit(float z, float z0, float vs){
	fitout = exp(-(0.5)*sum(((z-z0)^2/(vs))));
	return fitout;
}

initialize() {

	// Set seed
	theseed = rdunif(1,0,asInteger(2^62)-1);
	catn("New random seed is " + theseed);
	setSeed(theseed);
	
	defineConstant("N",5000);				// Population size
	defineConstant("QTLf",0.1);			// Fraction of mutations that code for QTLs
	defineConstant("genl",30000000);		// Length of simulated genome
	
	// Uncomment if running on home machine; comment out otherwise
//	defineConstant("s",0.0);				// Background mutation selection coefficient
//	defineConstant("h",0.02);				// Background mutation dominance coefficient
//	defineConstant("sfrate",0.0);			// Self-fertilisation rate
//	defineConstant("nt",1); 				// Number of traits to optimise
//	defineConstant("newo",1.0);			// New optimum after trait shift
//	defineConstant("msd",0.25);			// Standard Deviation in trait values
//	defineConstant("rep",1);				// Which replicate is running
//	defineConstant("isloc",1);				// 'Is local machine', for printing to computer
	
	// Defining where to print stats out to, depending on code location
	if( exists("isloc") )
	{
		defineConstant("fname",paste0(c("/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM Scripts/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_msd",msd,"_rep",rep,".dat")));
	}
	else
	{
		defineConstant("fname",paste0(c("/scratch/mhartfield/polyself_out/data/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_msd",msd,"_rep",rep,".dat")));
	}
	
	defineConstant("ShiftTime",5*N);
	defineConstant("MaxTime",5*N+502);				// Let sims run for ~500 generations after shift
	defineConstant("mutvar",msd*msd);				// Mutational variance in covariance matrix (= sd^2)
	
	initializeMutationType("m1", h, "f", s); 	 			// Fitness of background mutations (set to zero for neutral)
	initializeMutationType("m2", 0.5, "f", 0.0);  	 	// QTLs		
	m1.mutationStackPolicy = "f";
	m2.convertToSubstitution = F;
	m2.mutationStackPolicy = "f";
	m2.color="green";
	
	initializeGenomicElementType("g1", c(m1,m2), c(1.0-QTLf,QTLf));
//	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, genl-1);
	
	// Uncomment if using Arabidopsis-type parameters
	mu = 1e-9;
	rec = ((3.6*0.01)/(1000000-1));
	
	// Uncomment if using testing values
//	mu = 1e-6;
//	rec = 0.0005;
	
	initializeMutationRate(mu);
	initializeRecombinationRate(rec);
	
	// Setting up multivariate trait matrix
	defineConstant("QTL_mean",rep(0.0,nt));
	defineConstant("QTL_io",rep(0.0,nt));			// Initial optimum = 0
	defineConstant("QTL_so",rep(newo,nt));			// Shifted optimum	
	defineConstant("QTL_V",mutvar);					// Variance in mutational effects
	defineConstant("QTL_CV",0.0);						// Co-variance in mutational effects
	
	// Setting up array to be used to define QTL covariance matrix
	mat_ent = rep(QTL_CV,nt*nt);
	for (i in 1:nt)
	{
		ent = 0.0 + (i-1)*(nt+1);
		mat_ent[ent] = QTL_V;
	}
	defineConstant("QTL_matrix",matrix(mat_ent,nrow=nt));
	print(QTL_matrix);
}

// Calculating fitness contributed by QTLs
fitness(NULL)
{
	phens = rep(0.0,nt);
	mQTL = individual.genomes.mutationsOfType(m2);
	if(size(mQTL) != 0){
		for(i in 1:nt)
		{
			phens[(i-1)] = sum(mQTL.getValue(paste0(c("e",(i-1)))));
		}
	}
		
	// Fitness scaling of QTLs based on Gaussian function with selection variance = 1
	if(sim.generation < ShiftTime)
	{
		return gaussfit(phens,QTL_io,rep(1.0,nt));
	}
	else if(sim.generation >= ShiftTime)
	{
		return gaussfit(phens,QTL_so,rep(1.0,nt));
	}
}

// Defining selection coefficient of QTL mutations using MVN setup (in base population)
mutation(m2,p1)
{
	if(nt > 1)
	{
		effects = rmvnorm(1,QTL_mean,QTL_matrix);
		for(i in 1:nt)
		{
			mut.setValue( paste0(c("e",(i-1))) , effects[i-1]);
		}
	}
	else if (nt == 1)
	{
		effects = rnorm(1,QTL_mean,sqrt(QTL_V));	// note sqrt, as rnorm uses sd of effects
		mut.setValue( "e0" , effects);
	}
	return T;
}

// Supressing ALL mutation in p2, p3 (subpops in which inbreeding depression is measured)
mutation(m1,p2)
{
	return F;
}
mutation(m2,p2)
{
	return F;
}
mutation(m1,p3)
{
	return F;
}
mutation(m2,p3)
{
	return F;
}

// Code to define fitness changes due to QTLs
late () {
	
	if (sim.generation % sim.getValue('p2time') == 0){
		catn("Generation number " + sim.generation);
	}
	
	if (sim.generation == ShiftTime){
		catn("Optimum shift at generation " + sim.generation);
	}
	
	// Print out VCF stats of 50 individuals, along with QTL positions, for calculating haplotype statistics
	// (Only for first rep for now)
	
	if( rep == 1 )
	{
		if( (sim.generation == (ShiftTime - 1)) | (sim.generation == (ShiftTime + 20)) | (sim.generation == (ShiftTime + 150)) )
		{	
		
			// Printout folder, depending on local machine or not
			if( exists("isloc") )
			{
				ftext = "/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM scripts/VCFout/VCFout_test_";
			}
			else
			{
				ftext = paste0(c("/scratch/mhartfield/polyself_out/haps/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_msd",msd,"_"));
			}
		
			// File suffix
			if( (sim.generation == (ShiftTime - 1)) )
			{
				stext = "beforeshift";
			}
			else if( (sim.generation == (ShiftTime + 20)) )
			{
				stext = "20gens";
			}
			else if( (sim.generation == (ShiftTime + 150)) )
			{
				stext = "150gens";
			}

			// Write output files
			p1.outputVCFSample(50,replace=F,filePath=paste0(c(ftext,stext,".vcf")));
			writeFile(paste0(c(ftext,stext,".pos")),paste(sort(sim.mutationsOfType(m2).position+1),"\n"));

		}
	}
	
//	if ( (sim.generation == (ShiftTime-1)) & (rep==1) ){
//	

//	}
//	
//	if ( (sim.generation == (ShiftTime + 20)) & (rep==1) ){
//		p1.outputMSSample(100,replace=F,filePath=paste0(c("/scratch/mhartfield/polyself_out/ms/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_msd",msd,"_rep",rep,"_aftershift.ms")));
//	}
//	
//	if ( (sim.generation == (ShiftTime + 150) ) & (rep==1) ){
//		p1.outputMSSample(100,replace=F,filePath=paste0(c("/scratch/mhartfield/polyself_out/ms/polyself_out_s",s,"_h",h,"_self",sfrate,"_nt",nt,"_newo",newo,"_msd",msd,"_rep",rep,"_simend.ms")));
//	}

}

// Outputting key statistics every 100 generations (or every 10 just after optimum shift)
early () {

	if(sim.generation == ShiftTime)
	{
		sim.setValue('ptime',10);
		sim.setValue('p2time',50);		
		catn("Printout now every " + sim.getValue('ptime') + " generations.");
	}
	
	if(sim.generation == (ShiftTime + 500) | sim.generation == 1)
	{
		sim.setValue('ptime',100);
		sim.setValue('p2time',500);
		catn("Printout now every " + sim.getValue('ptime') + " generations.");
	}
	
	if (sim.generation % sim.getValue('ptime') == 0 & sim.generation >= 4*N){
		// Splitting off subpopulations, for measuring inbreeding depression
		sim.addSubpopSplit("p2",500,p1);
		sim.addSubpopSplit("p3",500,p1);
		p2.setSelfingRate(0.0);
		p3.setSelfingRate(1.0);
	}

	if (sim.generation % sim.getValue('ptime') == 1 & sim.generation >= 4*N){
		cumphen = rep(0.0,nt);			// Cumulative phenotype (for mean)
		cumphensq = rep(0.0,nt);		// Cumulative square of phenotype (for variance)
		cumfit = 0.0;						// Cumulative fitness (for mean)
		cumfitsq = 0.0;					// Cumulative square of fitness (for variance)
		genvar = rep(0.0,nt);			// Genetic variance
		fixeff = rep(0.0,nt);			// Mean QTL effects of mutants that fix
		proppos = rep(0.0,nt);			// Proportion of QTLs with +ve effects
		fepos = rep(0.0,nt);				// Mean QTL effects of fixed *positive* mutations
		
		// QTL loci
		phens = rep(0.0,nt);
		for (ind in p1.individuals)
		{
			mQTL = ind.genomes.mutationsOfType(m2);
			if(size(mQTL) != 0){
				for(i in 1:nt)
				{
					phens[(i-1)] = sum(mQTL.getValue(paste0(c("e",(i-1)))));
					cumphen[(i-1)] = cumphen[(i-1)] + phens[(i-1)];
					cumphensq[(i-1)] = cumphensq[(i-1)] + (phens[(i-1)])^2;
				}
			}			
		}
		
		qtls = sim.mutationsOfType(m2);
		qtlf = sim.mutationFrequencies(p1,qtls);
		fmuts = sum(qtlf == 1.0);
		line = paste(c(sim.generation, mean(p1.cachedFitness(NULL)), var(p1.cachedFitness(NULL)), fmuts));
		
		// Measuring inbreeding depression, deleting subpopulations
		id = 1.0 - (mean(p3.cachedFitness(NULL))/mean(p2.cachedFitness(NULL)));
		line = c(line,id);
		p2.setSubpopulationSize(0);
		p3.setSubpopulationSize(0);
		
		for(i in 1:nt)
		{
			if(size(qtls) != 0)
			{
				// Calculating genetic variance
				qtle = qtls.getValue(paste0(c("e",(i-1))));
				genvar[(i-1)] = sum(2*qtlf*(1.0-qtlf)*qtle*qtle);
				if(size(qtle[which(qtlf==1.0)]) == 0)
				{
					fixeff[(i-1)] = NAN;
					proppos[(i-1)] = NAN;
					fepos[(i-1)] = NAN;
				}
				else
				{
					fixeff[(i-1)] = mean(qtle[which(qtlf==1.0)]);
					proppos[(i-1)] = size(qtle[which(qtlf==1.0 & qtle>0.0)])/size(qtle[which(qtlf==1.0)]);
					if(size(qtle[which(qtlf==1.0 & qtle>0.0)]) > 0)
					{
						fepos[(i-1)] = mean(qtle[which(qtlf==1.0 & qtle>0.0)]);
					}
					else
					{
						fepos[(i-1)] = NAN;
					}
				}
			}
			else
			{
				genvar[(i-1)] = 0.0;
				fixeff[(i-1)] = NAN;
				proppos[(i-1)] = NAN;
				fepos[(i-1)] = NAN;
			}
			
			// Printing out mean individual phenotype; variance in indv phenotype; population genetic variance
			line = c(line,cumphen[(i-1)]/N);
			line = c(line,(cumphensq[(i-1)]/N) - (cumphen[(i-1)]/N)^2);
			line = c(line,genvar[(i-1)]);
			line = c(line,fixeff[(i-1)]);
			line = c(line,proppos[(i-1)]);
			line = c(line,fepos[(i-1)]);
		}
		
		// Outputting statistics
		writeFile(fname, paste(line), append=T);	
	}
}

1 {
	// Set up population size and printouts
	sim.addSubpop("p1", N);
	p1.setSelfingRate(sfrate);
	line = c("Generation", "MeanFitness", "VarFitness", "FixedMuts","InbreedingDepression");
	for(i in 1:nt)
	{
		line = c(line,paste0(c("MeanTrait",i)));
		line = c(line,paste0(c("VarTrait",i)));
		line = c(line,paste0(c("GenVar",i)));
		line = c(line,paste0(c("MeanFixedQTL",i)));
		line = c(line,paste0(c("PropPosQTL",i)));
		line = c(line,paste0(c("MeanPosQTL",i)));
	}
	writeFile(fname, paste(line), append=F);
	sim.rescheduleScriptBlock(s1,MaxTime,MaxTime);
	sim.setValue('hasfixed',0);
}

// To be run after 'MaxTime' generations: terminate simulation 
s1 10 late() {
	catn( MaxTime + " generations elapsed, end of simulation.");
	sim.simulationFinished();
}

// EOF