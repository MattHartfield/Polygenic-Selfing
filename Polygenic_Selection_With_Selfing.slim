// 22nd October 2019
// Modification of recipes 13.2, 13.5
// Polygenic selection under selfâ€“fertilisation, with m traits under selection
// Is there a transition from gene-level to genome-level selection?
// How do the sweep dynamics differ?

// Function for calculating gaussian fitness function for multiple traits
function (f)gaussfit(float z, float z0, float vs){
	fitout = exp(-(0.5)*sum(((z-z0)^2/(vs))));
	return fitout;
}

initialize() {
	
	defineConstant("N",2500);
	defineConstant("ShiftTime",2*N);
	defineConstant("MaxTime",2*ShiftTime);	
	
	initializeMutationType("m1", 0.2, "f", 0.0); 	 	// Fitness of background mutations (set to zero for neutral)
	initializeMutationType("m2", 0.5, "f", 0.0);  	 	// QTLs		
	m2.convertToSubstitution = F;
	m2.color="green";
	
	QTLf = 0.05;	// Fraction of mutations that code for QTLs
//	initializeGenomicElementType("g1", c(m1,m2), c(1.0-QTLf,QTLf));
	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, 99999);
	
//	mu = 0.028/(100000*(1.0-QTLf));
	mu = 1e-7;
	rec = (2.5*0.01)/(1000000);
	initializeMutationRate(mu);
	initializeRecombinationRate(rec);
	
	// Setting up multivariate trait matrix
	defineConstant("nt",1); 	// Number of traits under selection
	defineConstant("QTL_mean",rep(0.0,nt));
	defineConstant("QTL_io",rep(0.0,nt));			// Initial optimum = 0
	defineConstant("QTL_so",rep(0.1,nt));			// Shifted optimum	
	defineConstant("QTL_V",0.005);					// Variance in mutational effects
	defineConstant("QTL_CV",0.0);						// Co-variance in mutational effects
	
	// Setting up array to be used to define QTL covariance matrix
	mat_ent = rep(QTL_CV,nt*nt);
	for (i in 1:nt)
	{
		ent = 0.0 + (i-1)*(nt+1);
		mat_ent[ent] = QTL_V;
	}
	defineConstant("QTL_matrix",matrix(mat_ent,nrow=nt));
	print(QTL_matrix);
}

// Defining fitness of QTL mutations using MVN setup
mutation(m2)
{
	if(nt > 1)
	{
		effects = rmvnorm(1,QTL_mean,QTL_matrix);
		for(i in 1:nt)
		{
			mut.setValue( paste0(c("e",(i-1))) , effects[i-1]);
		}
	}
	else if (nt == 1)
	{
		effects = rnorm(1,QTL_mean,QTL_V);
		mut.setValue( "e0" , effects);
	}
	return T;
}

// Code to define fitness changes due to effects of QTLs
late () {
	
	for (ind in sim.subpopulations.individuals)
	{
			
		// QTL loci
		phens = rep(0.0,nt);
		mQTL = ind.genomes.mutationsOfType(m2);
		if(size(mQTL) != 0){
			for(i in 1:nt)
			{
				phens[(i-1)] = sum(mQTL.getValue(paste0(c("e",(i-1)))));
			}
		}
		
		// Fitness scaling of QTLs based on Gaussian function with selection variance = 1
		if(sim.generation <= ShiftTime)
		{
			ind.fitnessScaling = gaussfit(phens,QTL_io,rep(1.0,nt));
		}
		else if(sim.generation > ShiftTime)
		{
			ind.fitnessScaling = gaussfit(phens,QTL_so,rep(1.0,nt));
		}
	}
}

1 {
	// Set up subpop size and printouts
	sim.addSubpop("p1", N);
	p1.setSelfingRate(0);
	line = c("Generation", "MeanFitness", "VarFitness", "FixedMuts");
	for(i in 1:nt)
	{
		line = c(line,paste0(c("MeanTrait",i)));
		line = c(line,paste0(c("VarTrait",i)));
	}
	writeFile("/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM Scripts/output.dat", paste(line), append=F);
	sim.rescheduleScriptBlock(s1,99,MaxTime);
	sim.rescheduleScriptBlock(s2,MaxTime,MaxTime);	
}

s1 10 {
	// Outputting key statistics
	if (sim.generation % 100 == 0){
		qtls = sim.mutationsOfType(m2);
		fmuts = sum(sim.mutationFrequencies(NULL, qtls) == 1.0);
		line = paste(c(sim.generation, mean(p1.cachedFitness(NULL)), var(p1.cachedFitness(NULL)), fmuts));
		nopt = 0;
		for(i in 1:nt)
		{
			tv = qtls.getValue( paste0( c("e",(i-1)) ) );
			line = c(line,mean(tv));
			line = c(line,var(tv));
			if(sim.generation > ShiftTime)
			{
				// Count how many traits are within 5% of the optimum.
				// If all 'nt' sufficiently close after optimum shift then simulation ends (see next set of code)
				print(mean(tv));
				print((abs(mean(tv) - QTL_so[(i-1)])/QTL_so[(i-1)]));
				if((abs(mean(tv) - QTL_so[(i-1)])/QTL_so[(i-1)]) <= 0.05)
				{
					nopt = nopt + 1;
				}
				catn();				
			}
		}
		writeFile("/Users/hartfield/Documents/Polygenic Selection Selfing/SLiM Scripts/output.dat", paste(line), append=T);
		
		// If population adapted to its new optimum, OR if already ran for >5N generations, then end
		if(sim.generation > ShiftTime & nopt == nt)
		{
			catn("Population reached new optimum.");
			sim.simulationFinished();
		}
		
	}
}

// To be run after 10N generations: terminate simulation if have not reached new optimum
s2 10 {
	catn("Population failed to reach new optimum.");
	sim.simulationFinished();
}

// EOF